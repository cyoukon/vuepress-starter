import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,f as a,a as s,o as l}from"./app-dX-INNG3.js";const t="/vuepress-starter/assets/f6c6c1ccab28c589d07a9bb60a079ee8-COg1v883.jpg",p="/vuepress-starter/assets/6db843bf335555168fd69f5d58592356-DgE37U8v.jpg",d={};function r(h,i){return l(),n("div",null,i[0]||(i[0]=[a(`<h1 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h1><h2 id="_1-为什么要使用restful架构" tabindex="-1"><a class="header-anchor" href="#_1-为什么要使用restful架构"><span>1. 为什么要使用RESTful架构？</span></a></h2><ul><li><p>REST 是 Representational State Transfer的缩写，如果一个架构符合REST原则，就称它为RESTful架构</p></li><li><p>RESTful 架构可以充分的利用 HTTP 协议的各种功能，是 HTTP 协议的最佳实践</p></li><li><p>RESTful API 是一种软件架构风格、设计风格，可以让软件更加清晰，更简洁，更有层次，可维护性更好</p></li></ul><h2 id="_2-api-请求设计" tabindex="-1"><a class="header-anchor" href="#_2-api-请求设计"><span>2. API 请求设计</span></a></h2><table><thead><tr><th>HTTP动词</th><th>宾语 URL</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>/zoos</td><td>列出所有动物园</td></tr><tr><td>POST</td><td>/zoos</td><td>新建一个动物园</td></tr><tr><td>GET</td><td>/zoos/:id</td><td>获取某个指定动物园的信息</td></tr><tr><td>PUT</td><td>/zoos/:id</td><td>更新某个指定动物园的全部信息</td></tr><tr><td>PATCH</td><td>/zoos/:id</td><td>更新某个指定动物园的部分信息</td></tr><tr><td>DELETE</td><td>/zoos/:id</td><td>删除某个动物园</td></tr><tr><td>GET</td><td>/zoos/:id/animals</td><td>列出某个指定动物园的所有动物</td></tr><tr><td>DELETE</td><td>/zoos/:id/animals/:id</td><td>删除某个指定动物园的指定动物</td></tr></tbody></table><blockquote><p>请求 = 动词 + 宾语</p><ul><li><p>动词 使用五种 HTTP 方法，对应 CRUD 操作。</p></li><li><p>宾语 URL 应该全部使用名词复数，可以有例外，比如搜索可以使用更加直观的 search 。</p></li><li><p>过滤信息（Filtering） 如果记录数量很多，API应该提供参数，过滤返回结果。 ?limit=10 指定返回记录的数量 ?offset=10 指定返回记录的开始位置。</p></li></ul></blockquote><h2 id="_3-api-响应设计" tabindex="-1"><a class="header-anchor" href="#_3-api-响应设计"><span>3. API 响应设计</span></a></h2><blockquote><p>使用 HTTP 的状态码</p><ul><li>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</li><li>五大类状态码，总共100多种，覆盖了绝大部分可能遇到的情况。每一种状态码都有约定的解释，客户端只需查看状态码，就可以判断出发生了什么情况。API 不需要1xx状态码。</li></ul></blockquote><blockquote><p>1xx 相关信息</p><p>2xx 操作成功</p><p>3xx 重定向</p><p>4xx 客户端错误</p><p>5xx 服务器错误</p></blockquote><h2 id="_4-服务器回应数据" tabindex="-1"><a class="header-anchor" href="#_4-服务器回应数据"><span>4. 服务器回应数据</span></a></h2><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    POST /articles</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Authorization:eyJ</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">eXAiOiJKV</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">QiLCJhbGciOiJI......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    content-type: application/json</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        &quot;title&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;舟夜书所见&quot;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;content&quot;</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;月黑见渔灯,孤光一点萤。微微风簇浪,散作满河星。&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    201</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Created</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        &quot;id&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;123e4567-e89b-12d3-a456-426655440000&quot;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;title&quot;</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;舟夜书所见&quot;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;content&quot;</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;月黑见渔灯,孤光一点萤。微微风簇浪,散作满河星。&quot;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">        &quot;create_time&quot;</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11),s("ul",null,[s("li",null,[s("p",null,"客户端请求时，要明确告诉服务器，接受 JSON 格式，请求的 HTTP 头的 ACCEPT 属性要设成 application/json")]),s("li",null,[s("p",null,"服务端返回的数据，不应该是纯文本，而应该是一个 JSON 对象。服务器回应的 HTTP 头的 Content-Type 属性要设为 application/json")]),s("li",{"error:":"",InvalidAPIkey:""},[s("p",null,"错误处理 如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将 error 作为键名，出错信息作为键值即可。")]),s("li",null,[s("p",null,"认证 RESTful API 应该是无状态，每个请求应该带有一些认证凭证。推荐使用 JWT 认证，并且使用 SSL")]),s("li",null,[s("p",null,"Hypermedia 即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么")])],-1),a(`<h1 id="api-请求" tabindex="-1"><a class="header-anchor" href="#api-请求"><span>API 请求</span></a></h1><h2 id="_1-http-动词" tabindex="-1"><a class="header-anchor" href="#_1-http-动词"><span>1. HTTP 动词</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>GET：   读取（Read）</span></span>
<span class="line"><span>POST：  新建（Create）</span></span>
<span class="line"><span>PUT：   更新（Update）</span></span>
<span class="line"><span>PATCH： 更新（Update），通常是部分更新</span></span>
<span class="line"><span>DELETE：删除（Delete）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-url-宾语-必须是名词" tabindex="-1"><a class="header-anchor" href="#_2-url-宾语-必须是名词"><span>2. URL（宾语）必须是名词</span></a></h2><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/getAllCars</span></span>
<span class="line"><span>/createNewCar</span></span>
<span class="line"><span>/deleteAllRedCars</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>既然 URL 是名词，为了统一起见，建议都使用复数。</p><h2 id="_3-举个例子" tabindex="-1"><a class="header-anchor" href="#_3-举个例子"><span>3. 举个例子</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>GET    /zoos：列出所有动物园</span></span>
<span class="line"><span>POST   /zoos：新建一个动物园</span></span>
<span class="line"><span>GET    /zoos/ID：获取某个指定动物园的信息</span></span>
<span class="line"><span>PUT    /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span></span>
<span class="line"><span>PATCH  /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span></span>
<span class="line"><span>DELETE /zoos/ID：删除某个动物园</span></span>
<span class="line"><span>GET    /zoos/ID/animals：列出某个指定动物园的所有动物</span></span>
<span class="line"><span>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-过滤信息-filtering" tabindex="-1"><a class="header-anchor" href="#_4-过滤信息-filtering"><span>4. 过滤信息（Filtering）</span></a></h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><p>下面是一些常见的参数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>?limit=10：指定返回记录的数量</span></span>
<span class="line"><span>?offset=10：指定返回记录的开始位置。</span></span>
<span class="line"><span>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span></span>
<span class="line"><span>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span></span>
<span class="line"><span>?animal_type_id=1：指定筛选条件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h2 id="_5-不符合-crud-情况的-restful-api" tabindex="-1"><a class="header-anchor" href="#_5-不符合-crud-情况的-restful-api"><span>5. 不符合 CRUD 情况的 RESTful API</span></a></h2><p>在实际资源操作中，总会有一些不符合 CRUD（Create-Read-Update-Delete） 的情况，一般有几种处理方法。</p><ol><li><p>使用 POST，为需要的动作增加一个 endpoint，使用 POST 来执行动作，比如: POST /resend 重新发送邮件。</p></li><li><p>增加控制参数，添加动作相关的参数，通过修改参数来控制动作。比如一个博客网站，会有把写好的文章“发布”的功能，可以用上面的 POST /articles/{:id}/publish 方法，也可以在文章中增加 published:boolean 字段，发布的时候就是更新该字段 PUT /articles/{:id}?published=true</p></li><li><p>把动作转换成资源，把动作转换成可以执行 CRUD 操作的资源， github 就是用了这种方法。</p></li></ol><blockquote><p>比如“喜欢”一个 gist，就增加一个 /gists/:id/star 子资源，然后对其进行操作：“喜欢”使用PUT /gists/:id/star，“取消喜欢”使用 DELETE /gists/:id/star。<br> 另外一个例子是 Fork，这也是一个动作，但是在 gist 下面增加 forks资源，就能把动作变成 CRUD 兼容的：POST /gists/:id/forks 可以执行用户 fork 的动作。</p></blockquote><h2 id="_6-动词覆盖-应对服务器不支持-http-的情况" tabindex="-1"><a class="header-anchor" href="#_6-动词覆盖-应对服务器不支持-http-的情况"><span>6. 动词覆盖，应对服务器不支持 HTTP 的情况</span></a></h2><p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。</p><p>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p><h1 id="api-响应" tabindex="-1"><a class="header-anchor" href="#api-响应"><span>API 响应</span></a></h1><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p>HTTP 状态码就是一个三位数，分成五个类别。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1xx：相关信息</span></span>
<span class="line"><span>2xx：操作成功</span></span>
<span class="line"><span>3xx：重定向</span></span>
<span class="line"><span>4xx：客户端错误</span></span>
<span class="line"><span>5xx：服务器错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p><h2 id="_2-状态码" tabindex="-1"><a class="header-anchor" href="#_2-状态码"><span>2. 状态码</span></a></h2><p><strong>1xx 状态码</strong></p><p>API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。</p><p><strong>2xx 状态码</strong></p><p>200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>GET:    200 OK</span></span>
<span class="line"><span>POST:   201 Created</span></span>
<span class="line"><span>PUT:    200 OK</span></span>
<span class="line"><span>PATCH:  200 OK</span></span>
<span class="line"><span>DELETE: 204 No Content</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。</p><p><strong>3xx 状态码</strong></p><p>API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p><p>API 主要是用303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是&quot;暂时重定向&quot;，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HTTP/1.1 303 See Other</span></span>
<span class="line"><span>Location: /api/orders/12345</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4xx 状态码</strong></p><p>4xx 状态码表示客户端错误，主要有下面几种：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>400 Bad Request：服务器不理解客户端的请求，未做任何处理。</span></span>
<span class="line"><span>401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span></span>
<span class="line"><span>403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span></span>
<span class="line"><span>404 Not Found：所请求的资源不存在，或不可用。</span></span>
<span class="line"><span>405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span></span>
<span class="line"><span>410 Gone：所请求的资源已从这个地址转移，不再可用。</span></span>
<span class="line"><span>415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span></span>
<span class="line"><span>422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span></span>
<span class="line"><span>429 Too Many Requests：客户端的请求次数超过限额。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5xx 状态码</strong></p><p>5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。</span></span>
<span class="line"><span>503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-返回数据" tabindex="-1"><a class="header-anchor" href="#_3-返回数据"><span>3. 返回数据</span></a></h2><p><strong>3.1 不要返回纯本文</strong></p><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。</p><p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。</p><p><strong>3.2 不要包装数据</strong></p><p>response 的 body直接就是数据，不要做多余的包装。错误实例：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;success&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;data&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;id&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;周伯通&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>GET    /collection：返回资源对象的列表（数组）</span></span>
<span class="line"><span>GET    /collection/resource：返回单个资源对象</span></span>
<span class="line"><span>POST   /collection：返回新生成的资源对象</span></span>
<span class="line"><span>PUT    /collection/resource：返回完整的资源对象</span></span>
<span class="line"><span>PATCH  /collection/resource：返回完整的资源对象</span></span>
<span class="line"><span>DELETE /collection/resource：返回一个空文档</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.3 发生错误时，不要返回 200 状态码</strong></p><p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;status&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;failure&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;data&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Expected at least two items in list.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">HTTP/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 400</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Bad Request</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Content-Type: application/json</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Invalid payoad.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;detail&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;surname&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;This field is required.&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="jwt-认证" tabindex="-1"><a class="header-anchor" href="#jwt-认证"><span>JWT 认证</span></a></h1><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><h2 id="_1-跨域认证的问题" tabindex="-1"><a class="header-anchor" href="#_1-跨域认证的问题"><span>1. 跨域认证的问题</span></a></h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><ol><li><p>用户向服务器发送用户名和密码。</p></li><li><p>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p></li><li><p>服务器向用户返回一个 session_id，写入用户的 Cookie。</p></li><li><p>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p></li><li><p>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></li></ol><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="_2-jwt-的原理" tabindex="-1"><a class="header-anchor" href="#_2-jwt-的原理"><span>2. JWT 的原理</span></a></h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> &quot;姓名&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;张三&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> &quot;角色&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;管理员&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> &quot;到期时间&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;2018年7月1日0点0分&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="_3-jwt-的数据结构" tabindex="-1"><a class="header-anchor" href="#_3-jwt-的数据结构"><span>3. JWT 的数据结构</span></a></h2><p>实际的 JWT 大概就像下面这样。</p><figure><img src="`+t+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Header（头部）</span></span>
<span class="line"><span>Payload（负载）</span></span>
<span class="line"><span>Signature（签名）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写成一行，就是下面的样子。</p><p>Header.Payload.Signature</p><figure><img src="`+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>下面依次介绍这三个部分。</p><p><strong>3.1 Header</strong></p><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;alg&quot;: &quot;HS256&quot;,</span></span>
<span class="line"><span>  &quot;typ&quot;: &quot;JWT&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><p><strong>3.2 Payload</strong></p><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>iss (issuer)：签发人</span></span>
<span class="line"><span>exp (expiration time)：过期时间</span></span>
<span class="line"><span>sub (subject)：主题</span></span>
<span class="line"><span>aud (audience)：受众</span></span>
<span class="line"><span>nbf (Not Before)：生效时间</span></span>
<span class="line"><span>iat (Issued At)：签发时间</span></span>
<span class="line"><span>jti (JWT ID)：编号</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;sub&quot;: &quot;1234567890&quot;,</span></span>
<span class="line"><span>  &quot;name&quot;: &quot;John Doe&quot;,</span></span>
<span class="line"><span>  &quot;admin&quot;: true</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><p><strong>3.3 Signature</strong></p><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（.）分隔，就可以返回给用户。</p><p><strong>3.4 Base64URL</strong></p><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 <a href="http://api.example.com/?token=xxx%EF%BC%89%E3%80%82Base64" target="_blank" rel="noopener noreferrer">api.example.com/?token=xxx）。Base64</a> 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p><h2 id="_4-jwt-的使用方式" tabindex="-1"><a class="header-anchor" href="#_4-jwt-的使用方式"><span>4. JWT 的使用方式</span></a></h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p><p>Authorization: Bearer</p><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="_5-jwt-的几个特点" tabindex="-1"><a class="header-anchor" href="#_5-jwt-的几个特点"><span>5. JWT 的几个特点</span></a></h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h2 id="_6-实现" tabindex="-1"><a class="header-anchor" href="#_6-实现"><span>6. 实现</span></a></h2><p>该页面列举了各种语言的 JWT 实现，<a href="https://jwt.io/libraries" target="_blank" rel="noopener noreferrer">https://jwt.io/libraries</a></p>`,116)]))}const k=e(d,[["render",r],["__file","RESTfulAPI.html.vue"]]),u=JSON.parse('{"path":"/guide/%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/RESTfulAPI.html","title":"简介","lang":"zh-CN","frontmatter":{"description":"简介 1. 为什么要使用RESTful架构？ REST 是 Representational State Transfer的缩写，如果一个架构符合REST原则，就称它为RESTful架构 RESTful 架构可以充分的利用 HTTP 协议的各种功能，是 HTTP 协议的最佳实践 RESTful API 是一种软件架构风格、设计风格，可以让软件更加清晰，...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/vuepress-starter/guide/%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/RESTfulAPI.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"简介"}],["meta",{"property":"og:description","content":"简介 1. 为什么要使用RESTful架构？ REST 是 Representational State Transfer的缩写，如果一个架构符合REST原则，就称它为RESTful架构 RESTful 架构可以充分的利用 HTTP 协议的各种功能，是 HTTP 协议的最佳实践 RESTful API 是一种软件架构风格、设计风格，可以让软件更加清晰，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-10T08:55:51.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-10T08:55:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-10T08:55:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 为什么要使用RESTful架构？","slug":"_1-为什么要使用restful架构","link":"#_1-为什么要使用restful架构","children":[]},{"level":2,"title":"2. API 请求设计","slug":"_2-api-请求设计","link":"#_2-api-请求设计","children":[]},{"level":2,"title":"3. API 响应设计","slug":"_3-api-响应设计","link":"#_3-api-响应设计","children":[]},{"level":2,"title":"4. 服务器回应数据","slug":"_4-服务器回应数据","link":"#_4-服务器回应数据","children":[]},{"level":2,"title":"1. HTTP 动词","slug":"_1-http-动词","link":"#_1-http-动词","children":[]},{"level":2,"title":"2. URL（宾语）必须是名词","slug":"_2-url-宾语-必须是名词","link":"#_2-url-宾语-必须是名词","children":[]},{"level":2,"title":"3. 举个例子","slug":"_3-举个例子","link":"#_3-举个例子","children":[]},{"level":2,"title":"4. 过滤信息（Filtering）","slug":"_4-过滤信息-filtering","link":"#_4-过滤信息-filtering","children":[]},{"level":2,"title":"5. 不符合 CRUD 情况的 RESTful API","slug":"_5-不符合-crud-情况的-restful-api","link":"#_5-不符合-crud-情况的-restful-api","children":[]},{"level":2,"title":"6. 动词覆盖，应对服务器不支持 HTTP 的情况","slug":"_6-动词覆盖-应对服务器不支持-http-的情况","link":"#_6-动词覆盖-应对服务器不支持-http-的情况","children":[]},{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. 状态码","slug":"_2-状态码","link":"#_2-状态码","children":[]},{"level":2,"title":"3. 返回数据","slug":"_3-返回数据","link":"#_3-返回数据","children":[]},{"level":2,"title":"1. 跨域认证的问题","slug":"_1-跨域认证的问题","link":"#_1-跨域认证的问题","children":[]},{"level":2,"title":"2. JWT 的原理","slug":"_2-jwt-的原理","link":"#_2-jwt-的原理","children":[]},{"level":2,"title":"3. JWT 的数据结构","slug":"_3-jwt-的数据结构","link":"#_3-jwt-的数据结构","children":[]},{"level":2,"title":"4. JWT 的使用方式","slug":"_4-jwt-的使用方式","link":"#_4-jwt-的使用方式","children":[]},{"level":2,"title":"5. JWT 的几个特点","slug":"_5-jwt-的几个特点","link":"#_5-jwt-的几个特点","children":[]},{"level":2,"title":"6. 实现","slug":"_6-实现","link":"#_6-实现","children":[]}],"git":{"createdTime":1733820951000,"updatedTime":1733820951000,"contributors":[{"name":"cyoukon","username":"cyoukon","email":"z1162289133@gmail.com","commits":1,"url":"https://github.com/cyoukon"}]},"readingTime":{"minutes":14.34,"words":4302},"filePathRelative":"guide/接口规范/RESTfulAPI.md","localizedDate":"2024年12月10日","autoDesc":true}');export{k as comp,u as data};
